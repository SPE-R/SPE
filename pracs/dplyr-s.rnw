% \documentclass{article}
% 
% \usepackage[utf8]{inputenc}
% \DeclareUnicodeCharacter{2139}{$\iota$}
% 
% \begin{document}
% \SweaveOpts{concordance=TRUE}

\SweaveOpts{results=verbatim, prefix.string=./graph/tab}

\section{Data manipulation with dplyr}

\subsection{Introduction}

In this chapter we will reproduce \textit{more or less} the same outputs as in chapter 1.3 using 
\texttt{tidyverse} packages suit.

The main goal is to familiarize you with some of the main \texttt{dplyr} and \texttt{tidyverse} features.
This is an optional practical for participants that have already good basic R basis. 
All the rest of the course can be done without knowing \texttt{dplyr}.


\subsection{The \texttt{births} data}

A quick description of the \texttt{births} data-set (from \texttt{Epi} package) can be found in 
chapter  1.3.2.\newline
First of all, load the \texttt{Epi} and \texttt{dplyr} packages. Then we should (re)load the 
births data-set.

<< >>=
library(Epi)
suppressPackageStartupMessages(library(dplyr))
data(births) 
@

\subsection{\texttt{tibble} vs \texttt{data.frame}}

Most \texttt{dplyr} functions outputs return \texttt{tibble} object instead of 
\texttt{data.frame}.\newline
Inspect the class and characteristics of the \texttt{births} object.

<< >>=
class(births)
births
@
\textbf{Note:} This can be summarized using \texttt{str} function

<< >>=
str(births)
@
\texttt{births} object is a 500 x 8 data.frame.\newline 
Let's convert \texttt{births} to \texttt{tibble} format with \texttt{as\_tibble} function.

<< >>=
births_tbl <- as_tibble(births)

class(births_tbl)
births_tbl

## another way to visualize data set is to use glimpse function
glimpse(births_tbl)
@
As you can see \texttt{tibble} inherits from \texttt{data.frame} which implies that all functions 
working with \texttt{data.frame} objects will work with \texttt{tibble} objects. The opposite is 
not necessary true. \texttt{tibble} has a couple of extra features compared to classical 
\texttt{data.frame}. One of them is a slightly more user-friendly console print. The main 
differences being that \texttt{tibble} objects supports grouping/nesting features. 
Some examples we be done will see latter on.

\subsection{Piping functions}

This is one of the most popular features of \texttt{tidyverse} grammar. It enables function chaining in 
\texttt{R}. Function outputs are passed as input to the following function and so on. 
It can help to make the code more readable.
Here is an example of classic vs piped functions.

<< >>=
head(births, 4)
births %>% head(4)
@
\textbf{Note:} By default the chained object is given as the first argument to the following 
function.
You can use \texttt{$.$} if this is not the case.\newline  
Here is a dummy example where we do not give the first argument to a function but the second one.
<< >>=
4 %>% head(births, .)
@

\subsection{\texttt{mutate} columns}

\texttt{mutate} will allow you to add and or modify columns in a \texttt{data.frame}.\newline
Let's create 2 new variables :
\begin{itemize}
  \item \texttt{agegrp} (5 years mother's age group) 
  \item \texttt{gest4} (gestation time split in 4 categories)
\end{itemize}
And modify 2 others:
\begin{itemize}
  \item \texttt{hyp} (factor version of \texttt{hyp}; \texttt{normal} vs \texttt{hyper}) 
  \item \texttt{sex} (factor version of \texttt{sex}; \texttt{M} vs \texttt{F}) 
\end{itemize}


<< >>=
births_tbl <-
  births_tbl %>%
  mutate(
    ## modify hyp varible (conversion into factor)
    hyp = factor(hyp, levels = c(0, 1), labels = c("normal", "hyper")),
    ## creating a new variable aggrep
    agegrp = cut(matage, breaks = c(20, 25, 30, 35, 40, 45), right = FALSE),
    ## modify sex variable (conversion into factor)
    sex = factor(sex, levels = c(1, 2), labels = c("M", "F")),
    ## creating a new variable gest4 with case_when instead of cut
    gest4 = 
      case_when(
        gestwks < 25 ~ 'less than 25 weeks',
        gestwks >= 25 & gestwks < 30  ~ '25-30 weeks',
        gestwks >= 30 & gestwks < 35  ~ '30-35 weeks',
        gestwks >= 35 & gestwks < 40  ~ '35-40 weeks',
        gestwks >= 40  ~ 'more than 40 weeks'
      ) 
  )

births_tbl
@

You can see in the table columns header the type of data contained in each column. 
For instance \texttt{<dbl>} stands for double (i.e. numeric value) and \texttt{fct}
stands for factor. In \texttt{R} \texttt{data.frame} (/ \texttt{tibble}) data type
have to be the same within a column (e.g. numeric only) but can be of different type across 
columns.

Notes than \texttt{case\_when} function do not return a \texttt{factor} but a \texttt{character} variable in this case.
You will have to force the conversion to \texttt{factor} if needed.


\subsection{\texttt{select} columns, \texttt{filter} and \texttt{arrange} rows}

\texttt{select} is used for column sub-setting while filter is for row sub-setting. 
They are equivalent to the \texttt{[]} in \texttt{R} base language.\newline
Let's display a table where only babies' \texttt{id}, \texttt{sex}, \texttt{bweight} and mothers' 
\texttt{agegrp} are kept for babies with a \texttt{bweight} grater than 4000g.

<< >>=
births_tbl %>%
  ## select only id, women age group, sex and birth weight of the baby
  select(id, agegrp, sex, bweight) %>%
  ## keep only babies weighing more than 4000g
  filter(bweight > 4000) 
@
\texttt{select} can also be useful to reorder and rename columns.\newline
\texttt{arrange} is a nice feature to reorder observations according to chosen attributes.\newline
Let's rename \texttt{agegrp}, \texttt{sex} and \texttt{bweight} with more explicit labels and reorder 
the table according to babies' decreasing birth weight.


<< >>=
births_tbl %>%
  ## select only id, women age group, sex and birth weight of the baby
  select(
    id, 
    'Age group' = agegrp, 
    Sex = sex, 
    'Birth weight' = bweight
  ) %>%
  ## rearrange rows to put the heaviest newborn on top
  arrange(desc(`Birth weight`))
@
\textbf{Note:} \texttt{tibble} supports blank spaces in the column names which can be handy for final table 
rendering. When you want to work with columns with blank spaces, do not forget to use the \texttt{$``$}
(back-quote).\newline
Let's do the same but arranging the table by decreasing birth weights within each sex.

<< >>=
births_tbl %>%
  ## select only id, women age group, sex and birth weight of the baby
  select(
    id, 
    'Age group' = agegrp, 
    Sex = sex, 
    'Birth weight' = bweight
  ) %>%
  ## rearrange rows to put the heaviest newborn on top
  arrange(Sex, desc(`Birth weight`))
@

\subsection{\texttt{group\_by} and \texttt{summarise} data}

One of the most valuable features of \texttt{dplyr} is the ability to aggregate data sharing a common
attribute to process by group operations.\newline
Here we want to compute the number of boys and girls in the data-set.\newline
The idea here is to split the \texttt{births} table in 2. One for boys, the other for girls and to 
count the number of rows of each sub-table.\newline

<< >>=
births.01 <-
  births_tbl %>%
  ## group the data according to the sex attribute
  group_by(sex) %>%
  ## count the number of rows/individuals in each group
  summarise(
    count = n()
  )
births.01
@
\textbf{Note:} \texttt{n} function is equivalent to \texttt{nrow}\newline 
Now we have the number of boys and girls, we can compute the percentage of newborns in each sex 
group.

<< >>= 
births.02 <-
  births.01 %>%
  mutate(
    percent = count / sum(count) * 100
  )
@
\textbf{Trick:} most of \texttt{dplyr} functions can be applied with an embedded condition using
\texttt{across} function. This can be very handy in some cases.\newline 
As an illustration if you want to calculate the \texttt{sum} of every \texttt{birth.02} numerical 
columns

<< >>=
births.03 <-
  births_tbl %>%
  select(gest4, sex, gestwks, bweight, matage) %>%
  group_by(gest4, sex) %>%
  summarise(
    across(
      where(is.numeric),
      ~ mean(.x, na.rm = TRUE)
    ),
    .groups = 'drop'
  )
births.03
@

\texttt{across} function supports the purrr-style lambda format, e.g. \texttt{~ mean(.x, na.rm = TRUE)}
where \texttt{.x} refers to the values from the data set to be passed to the function.

Some other functions ending by \texttt{\_with} can be used conditionally within \texttt{dplyr}.
As an example we can rename only columns which are not numeric at once (here we want to make all column names using upper characters) using
the combination of \texttt{rename\_with} and \texttt{where}.

<< >>=
births.03 %>%
  rename_with(toupper, where(~ !is.numeric(.x)))
@

Let's now compute the number of births and the mean birth weight according to newborn gender.

<< >>=
births.05 <-
  births_tbl %>%
  group_by(sex) %>%
  summarise(
    count = n(),
    bweight.mean = mean(bweight)
  )
births.05
@
With \texttt{births.05} table, compute the global mean new birth weight.\newline
\textbf{Note:} with such a table the mean baby's birth weight have to be weighted by number of boys 
and girls. 

<< >>=
births.05 %>%
  summarise(
    count.tot = sum(count),
    bweight.mean.tot = weighted.mean(bweight.mean, count)
  )

# this is equivalent to
births_tbl %>%
  summarise(
    count.tot = n(),
    bweight.mean.tot = mean(bweight)
  )
@


\subsection{Multiple grouping}

In some cases, we can be interested in looking at more than a single strata. This can be achieved 
using multiple grouping.\newline
Let's count the number of people per gender and birth weight class (low vs not low)

<< >>=
births.06 <-
  births_tbl %>%
  group_by(sex, lowbw) %>%
  summarise(
    count = n()
  )
births.06
@
Try then to compute the percentage of people in each group.\newline
Look at the difference between the 2 following command lines:

<< >>=
births.06 %>%
  mutate(
    percent = count / sum(count) * 100
  )

births.06 %>%
  ungroup() %>%
  mutate(
    percent = count / sum(count) * 100
  )
@
\textbf{Note:} summarizing a data-set will remove the latest level of grouping but not the deeper ones 
if multiple grouping has been done. In some cases you might have to explicitly ungroup your
\texttt{data.frame} before doing calculations. In the previous examples, if you do not ungroup
the data-set, percentages are computed per gender. Ungrouping will let you compute the overall 
percentages.\newline 

\textbf{Trick:} a good practice is to ungroup all the summarized dataset in order to prevent form 
confusion. You can do it using the \texttt{.group = 'drop'} option in \texttt{summarize()}. 

<< >>=
## this tibble will still be grouped by sex
births_tbl %>%
  group_by(sex, lowbw) %>%
  summarise(
    count = n()
  )

## this tibble will be group free
births_tbl %>%
  group_by(sex, lowbw) %>%
  summarise(
    count = n(),
    .groups = 'drop'
  )


@


The same exercise can be done using gestation time group (\texttt{gest4}) as stratifying variable.\newline
Lets compute number and mean birth weights according to gestation time category

<< >>=
births_tbl %>%
  group_by(gest4) %>%
  summarise(
    count = n(),
    bweight.mean = mean(bweight)
  )
@
Birth weight increases with gestation time.\newline
We can also spot that in our data-set the gestation time is missing for 10 newborns. 
We will remove this observation for the rest of the practical session. \newline 
Lets cross-tabulate the birth weight category and the gestation time groups.

<< >>=
births_tbl %>%
  ## keep only the newborn with defined gesational time category
  filter(
    !is.na(gest4)
  ) %>%
  group_by(lowbw, gest4) %>%
  ## compute the number of babies in each cross category
  summarise(
    count = n()
  ) %>%
  ## compute the percentage of babies in each gestational time category per 
  ## birth weight category
  mutate(
    percent = count / sum(count, na.rm = TRUE)
  )
@
Similarly we can be interested in the birth weight distribution per gestational time. 

<< >>=
births_tbl %>%
  filter(
    !is.na(gest4)
  ) %>%
  group_by(gest4, lowbw) %>%
  summarise(
    count = n()
  ) %>%
  ## compute the percentage of babies in each birth weight category per gestational 
  ## time category
  mutate(
    percent = count / sum(count, na.rm = TRUE)
  )
@
\textbf{Note:} grouping order matters! and can be confusing so think about ungrouping intermediate tables.

\subsection{Bind and join tables}

Another nice feature of \texttt{dplyr} is tables binding and joining functions. To practice we
will create 2 fake \texttt{tibble}:

\begin{itemize}
  \item \texttt{age} an individual database wich contains \texttt{pid} (unique individuals id) 
  and \texttt{age} in year
  \item \texttt{center} an study center database wich contains \texttt{pid} (unique individuals id)
  and \texttt{center} (the center where an individual is registered)
\end{itemize}

<< >>=
age <-
  tibble(
    pid = 1:6,
    age = sample(15:25, size = 6, replace = TRUE)
  )

center <-
  tibble(
    pid = c(1, 2, 3, 4, 10),
    center = c('A', 'B', 'A', 'B', 'C')
  )

age
center
@
Now the tables are define we will try to make the linkage between individuals ages and the center
they belong to.\newline
First of all let's have a look to \texttt{bind\_rows} function.

<< >>=
bind_rows(age, center)
@
Is it usfeful?\newline
Here not really but that can be in other situations (e.g. several individuals data base to merge..).\newline
\textbf{Note:} in \texttt{bind\_rows}, if columns names do not match, they are fill with \texttt{NA}.  

Here we want to join the 2 \texttt{tibble} according to the common attribute \texttt{pid}. Depending
on the context you can be interested in joining tables differently. Have a look at the differences
between \texttt{left\_join}, \texttt{full\_join} and \texttt{inner\_join}.

<< >>=
## all individuals from ages are kept
left_join(age, center)
## everithing is kept
full_join(age, center)
## only the individuals present in both dataset are kept
inner_join(age, center)
@
Can you spot the differences between the commands above?\newline
As a last exercise, try to compute the individuals' mean age per center.

<< >>=
inner_join(age, center) %>%
  group_by(center) %>%
  summarise(
    mean_age = mean(age)
  )
@


\subsection{Bonus: Rendering tables}

Once you have produced a nice data-set we can be interested in rendering it in a nice format that can
meet presentation/publication expectations. The \texttt{kableExtra} table can be useful to achieve 
this goal.

<< >>=
# if(!require(kableExtra)) install.packages('kableExtra')
# library(kableExtra)
# 
# births.08 <-
#   births_tbl %>%
#   filter(
#     !is.na(gest4)
#   ) %>%
#   group_by(gest4) %>%
#   summarise(
#     N = n()
#   ) %>%
#   mutate(
#     `(%)` = (N / sum(N)) %>% scales::percent()
#   )
# 
# ## default
# births.08
# 
# ## markdown flavour (useful fo automatic repport production with knitr)
# births.08 %>%
#   knitr::kable(fromat = 'markdown')
# 
# ## create an html version of the table and save it on the hard drive
# births.08 %>%
#   kable() %>%
#   kable_styling(
#     bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#     full_width = FALSE
#   ) %>%
#   save_kable(file = 'births.08.html', self_contained = TRUE)
@

<<echo=FALSE, eval=FALSE>>=
## trick to create dplyr-s.rnw file.
## this part have to be lauch manually
dplyr_e.path <- '~/OneDrive - IARC/PROJECT/_SPE/SPE/pracs/dplyr-e.rnw'
dplyr_e <- readLines(dplyr_e.path)
dplyr_s <- purrr::map_chr(dplyr_e, ~ sub('results=verbatim', 'results=verbatim', .x))
writeLines(dplyr_s, sub('-e.rnw$', '-s.rnw', dplyr_e.path))
@

% \end{document}
